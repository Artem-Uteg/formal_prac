# formal_prac

Утегенов Артем Б05-124

Даны α и натуральные числа k, l, такие что 0 ≤ l < k. 
Проверить, содержит ли язык L слова, чья длина равна l по модулю k.


ОШИБКИ:

(На стек кладем элементы по предложенному ниже алгоритму(см. строку 25))

1. mod <= remain

2. mod <= 1

3. remaind <= 0

4. В регулярном выражении есть символы не из алфавита.

5. В регулярное выражение не корректно или нельзя написать в обратной польской записи.
(plus) на стеке должно быть минимум 2 элемента.
(concatination) на стеке должно быть минимум 2 элемента.
(star) на стеке лежит минимум 1 элемент.

6. На стеке лежит больше одного элемента.


АЛГОРИТМ:

Добаляем данное регулярное выражение и поддерживаем его на стеке.
На стеке храннится массив длин строк по модулю, которые удавлетворяют данному выражению. 

1. symbol in [a, b, c]: {1}
Работает, т.к. элемен пораждает только слово длинны 1.

2. (empty_symbol) 1: {0}
Работает, т.к. элемен пораждает только слово длинны 0.

3. (plus) first_regex + second_regex: дизъюнкция first_regex и second_regex
Работает, т.к. у нас слова могут быть только те, что получались из исходных слов. 
Никаких новых слов не пораждается.

4. (concatenation) first_regex.second_regex: Нужно попарно сложить все элементы из 
                                                             first_regex и second_regex
Работает, т.к. к уже имеющимся словам одного массива мы прибавляем все слова другого массива.
Получается попарная сумма длин двух слов из разных массивов.

5. (stars) regex*: 1 + regex^2 + regex^3 + ... + regex^(mod - 1)
Работает, т.к. слово бесконечное колличество раз умножается на само себя,
значит идет concatenation слова на себя же. Почему умножаем до (mod - 1)?
У нас в классе эквивалентности всех вычетов до данного нам mod уже есть числа в степени после mod.
(Из курса ОКТЧ 2 семестра)

Если в нашем массиве есть значение, которое совпадает с данным нам остатком, то TRUE, иначе FALSE
